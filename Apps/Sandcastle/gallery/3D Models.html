<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
  <meta name="description" content="Create 3D models using glTF." />
  <meta name="cesium-sandcastle-labels" content="Tutorials,Showcases" />
  <title>Cesium Demo</title>
  <script type="text/javascript" src="../Sandcastle-header.js"></script>
  <script type="text/javascript" src="../../../Build/CesiumUnminified/Cesium.js" nomodule></script>
  <script type="module" src="../load-cesium-es6.js"></script>
</head>

<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
  <style>
    @import url(../templates/bucket.css);
  </style>
  <div id="cesiumContainer" class="fullSize"></div>
  <div id="loadingOverlay">
    <h1>Loading...</h1>
  </div>
  <div id="toolbar"></div>
  <script id="cesium_sandcastle_script">
    function startup(Cesium) {
      "use strict";
      //Sandcastle_Begin
      var viewer = new Cesium.Viewer("cesiumContainer", {
        infoBox: false,
        selectionIndicator: false,
        shadows: true,
        shouldAnimate: true,
      });

      const scene = viewer.scene
      scene.sun = null
      scene.highDynamicRange = true;
      var position = Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 0);

      const url = '../../SampleData/models/jiangxi.gltf';
      // const url = '../../SampleData/models/BoomBox/scene.gltf'
      // const url = '../../SampleData/models/CesiumAir/Cesium_Air.glb'
      // viewer.trackedEntity = viewer.entities.add({
      //     name : url,
      //     position,
      //     model : {
      //         uri : url,
      //         color: new Cesium.Color(1., 1., 1., 1),
      //         // scale : 40.0
      //     }
      // });

      const path = '../../SampleData/Cesium3DTiles/Tilesets/Private/3dtiles/tileset.json'
      const tileset = new Cesium.Cesium3DTileset({ url: path });

      scene.primitives.add(tileset);
      viewer.zoomTo(tileset)

      var z = 0

      // var blueBox = viewer.entities.add({
      //     name : 'Blue box',
      //     position:  Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, z),
      //     box : {
      //         dimensions : new Cesium.Cartesian3(10.0, 10.0, 10.0),
      //         material : Cesium.Color.BLUE
      //     }
      // });
      var clock = viewer.clock;
      var lastUpdated = clock.currentTime;
      clock.onTick.addEventListener(function() {
        var dt = Cesium.JulianDate.secondsDifference(clock.currentTime, lastUpdated);
        if (dt >= .1) {
          // Add a new sample position
          lastUpdated = clock.currentTime;
          // scene.lights[0].direction = scene.camera.directionWC
        }
      });

      scene.lights = [
        {
          type: 0, //directional
          direction: new Cesium.Cartesian3(0, 1, 0),
          color: new Cesium.Color(0, 0, 0)
        },
        {
          type: 1, //point
          position: new Cesium.Cartesian3(-1739076.5314795692, 5202317.7139456635, 3243654.20298938),
          color: new Cesium.Color(.3, 1.3, .3),
          constant: 1,
          linear: .09,
          quadratic: .032
        },
        // {
        //   type: 1, //pointl
        //   position: new Cesium.Cartesian3(-1739076.5314795692, 5202317.7139456635, 3243654.20298938),
        //   color: new Cesium.Color(10.3, 3, 6),
        //   constant: 1,
        //   linear: .09,
        //   quadratic: .032
        // }
      ]
      setTimeout(() => {
        scene.lights = []
        debugger
      }, 3000)

      const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
      handler.setInputAction(function(movement) {
        var pickedObject = scene.pick(movement.position);
        if (scene.pickPositionSupported && Cesium.defined(pickedObject) && pickedObject.id === viewer.trackedEntity) {
          var cartesian = viewer.scene.pickPositionWorldCoordinates(movement.position);
          console.log(cartesian.x, ',', cartesian.y, ',', cartesian.z)
          scene.lights[1].position = cartesian
        }


      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      viewer.scene.camera.setView({
        destination: new Cesium.Cartesian3(
          1216356.033078094,
          -4736402.278325668,
          4081270.375520902
        ),
        orientation: new Cesium.HeadingPitchRoll(
          0.08033365594766728,
          -0.29519015695063455,
          0.00027759141518046704
        ),
        endTransform: Cesium.Matrix4.IDENTITY,
      });

      var fragmentShaderSource =
        "float getDistance(sampler2D depthTexture, vec2 texCoords) \n" +
        "{ \n" +
        "    float depth = czm_unpackDepth(texture2D(depthTexture, texCoords)); \n" +
        "    if (depth == 0.0) { \n" +
        "        return czm_infinity; \n" +
        "    } \n" +
        "    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth); \n" +
        "    return -eyeCoordinate.z / eyeCoordinate.w; \n" +
        "} \n" +
        "float interpolateByDistance(vec4 nearFarScalar, float distance) \n" +
        "{ \n" +
        "    float startDistance = nearFarScalar.x; \n" +
        "    float startValue = nearFarScalar.y; \n" +
        "    float endDistance = nearFarScalar.z; \n" +
        "    float endValue = nearFarScalar.w; \n" +
        "    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); \n" +
        "    return mix(startValue, endValue, t); \n" +
        "} \n" +
        "vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) \n" +
        "{ \n" +
        "    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); \n" +
        "} \n" +
        "uniform sampler2D colorTexture; \n" +
        "uniform sampler2D depthTexture; \n" +
        "uniform vec4 fogByDistance; \n" +
        "uniform vec4 fogColor; \n" +
        "varying vec2 v_textureCoordinates; \n" +
        "void main(void) \n" +
        "{ \n" +
        "    float distance = getDistance(depthTexture, v_textureCoordinates); \n" +
        "    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \n" +
        "    float blendAmount = interpolateByDistance(fogByDistance, distance); \n" +
        "    vec4 undergroundColor = vec4(fogColor.rgb, fogColor.a * blendAmount); \n" +
        "    gl_FragColor = alphaBlend(undergroundColor, sceneColor); \n" +
        "} \n";

      var ellipsoid = viewer.scene.globe.ellipsoid;
      // var postProcessStage = viewer.scene.postProcessStages.add(
      //   new Cesium.PostProcessStage({
      //     fragmentShader: fragmentShaderSource,
      //     uniforms: {
      //       fogByDistance: new Cesium.Cartesian4(10, 0.0, 200, 1.0),
      //       fogColor: Cesium.Color.BLACK,
      //     },
      //   })
      // );
      //Sandcastle_End
      Sandcastle.finishedLoading();
    }
    if (typeof Cesium !== 'undefined') {
      window.startupCalled = true;
      startup(Cesium);
    }
  </script>
</body>

</html>